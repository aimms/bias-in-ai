## ams_version=1.0

Model Main_BiasInAI {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
		}
		Set s_ids {
			Index: i_id;
			Parameter: ep_id;
		}
		Parameter p_target {
			IndexDomain: i_id;
		}
		Parameter bp_target {
			IndexDomain: i_id;
			Definition: 1 $ ( p_target(i_id) > 0.7 );
		}
		StringParameter sp_commentText {
			IndexDomain: i_id;
		}
		Parameter p_severeToxicity {
			IndexDomain: i_id;
		}
		Parameter p_obscene {
			IndexDomain: i_id;
		}
		Parameter p_identityAttack {
			IndexDomain: i_id;
		}
		Parameter p_insult {
			IndexDomain: i_id;
		}
		Parameter p_threat {
			IndexDomain: i_id;
		}
		Parameter p_asian {
			IndexDomain: i_id;
		}
		Parameter p_atheist {
			IndexDomain: i_id;
		}
		Parameter p_bisexual {
			IndexDomain: i_id;
		}
		Parameter p_black {
			IndexDomain: i_id;
		}
		Parameter p_buddhist {
			IndexDomain: i_id;
		}
		Parameter p_christian {
			IndexDomain: i_id;
		}
		Parameter p_female {
			IndexDomain: i_id;
		}
		Parameter p_heterosexual {
			IndexDomain: i_id;
		}
		Parameter p_hindu {
			IndexDomain: i_id;
		}
		Parameter p_homosexualGayLesbian {
			IndexDomain: i_id;
		}
		Parameter p_intellectualLearningDisability {
			IndexDomain: i_id;
		}
		Parameter p_jewish {
			IndexDomain: i_id;
		}
		Parameter p_latino {
			IndexDomain: i_id;
		}
		Parameter p_male {
			IndexDomain: i_id;
		}
		Parameter p_muslim {
			IndexDomain: i_id;
		}
		Parameter p_otherDisability {
			IndexDomain: i_id;
		}
		Parameter p_otherGender {
			IndexDomain: i_id;
		}
		Parameter p_otherraceethnicity {
			IndexDomain: i_id;
		}
		Parameter p_otherReligion {
			IndexDomain: i_id;
		}
		Parameter p_otherSexualOrientation {
			IndexDomain: i_id;
		}
		Parameter p_physicalDisability {
			IndexDomain: i_id;
		}
		Parameter p_psychiatricMentalIllness {
			IndexDomain: i_id;
		}
		Parameter p_transgender {
			IndexDomain: i_id;
		}
		Parameter p_white {
			IndexDomain: i_id;
		}
		StringParameter sp_createdDate {
			IndexDomain: i_id;
		}
		Parameter p_publicationID {
			IndexDomain: i_id;
		}
		Parameter p_parentID {
			IndexDomain: i_id;
		}
		Parameter p_articleID {
			IndexDomain: i_id;
		}
		StringParameter sp_rating {
			IndexDomain: i_id;
		}
		Parameter p_funny {
			IndexDomain: i_id;
		}
		Parameter p_wow {
			IndexDomain: i_id;
		}
		Parameter p_sad {
			IndexDomain: i_id;
		}
		Parameter p_likes {
			IndexDomain: i_id;
		}
		Parameter p_disagree {
			IndexDomain: i_id;
		}
		Parameter p_sexualExplicit {
			IndexDomain: i_id;
		}
		Parameter p_identityAnnotatorCount {
			IndexDomain: i_id;
		}
		Parameter p_toxicityAnnotatorCount {
			IndexDomain: i_id;
		}
	}
	Section Integration {
		Procedure pr_importDataset {
			Body: {
				dex::AddMapping(
				        "CSVMapping",                   ! mapping name
				        "Mappings/csv-import-mapping.xml"       ! location + name of mapping file
				);
				
				dex::ReadFromFile(
				        "data/data.csv",                ! data file
				        "CSVMapping",                   ! mapping name, as specified in AddMapping
				        1,                              ! empty identifiers
				        1,                              ! empty range sets
				        1                               ! reset 'iterative-binds-to'
				);
				
				pr_changeQuantityElementsPerPage;
			}
		}
	}
	Section UI_Declarations {
		Procedure pr_empty;
		StringParameter sp_logo {
			Definition: "aimms_logo.png";
		}
		StringParameter sp_def_readonly {
			Definition: "readonly";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"            ,  ( 1, 1, icon              ) : "aimms-happy"        ,
					  ( 1, 1, pageId            ) : "home"               ,  ( 1, 1, tooltip           ) : "welcome"            ,
					  ( 1, 1, workflowPageState ) : "active"             ,  ( 1, 1, pageDataState     ) : "Incomplete"         ,
					  ( 1, 1, redirectPageId    ) : "problem_description",  ( 1, 2, displayText       ) : "Story"              ,
					  ( 1, 2, icon              ) : "aimms-lamp5"        ,  ( 1, 2, pageId            ) : "problem_description",
					  ( 1, 2, tooltip           ) : "Problem description",  ( 1, 2, workflowPageState ) : "active"             ,
					  ( 1, 2, pageDataState     ) : "incomplete"         ,  ( 1, 2, redirectPageId    ) : "home"               ,
					  ( 1, 3, displayText       ) : "Inputs"             ,  ( 1, 3, icon              ) : "aimms-equalizer2"   ,
					  ( 1, 3, pageId            ) : "inputs"             ,  ( 1, 3, tooltip           ) : "Input data"         ,
					  ( 1, 3, workflowPageState ) : "active"             ,  ( 1, 3, pageDataState     ) : "incomplete"         ,
					  ( 1, 3, redirectPageId    ) : "home"               ,  ( 1, 4, displayText       ) : "Results"            ,
					  ( 1, 4, icon              ) : "aimms-make-group"   ,  ( 1, 4, pageId            ) : "dashboard"          ,
					  ( 1, 4, tooltip           ) : "Model outputs"      ,  ( 1, 4, workflowPageState ) : "active"             ,
					  ( 1, 4, pageDataState     ) : "Incomplete"         ,  ( 1, 4, redirectPageId    ) : "home"                }
				}
			}
		}
		Section Pages {
			Section Inputs {
				Procedure pr_changeQuantityElementsPerPage {
					Body: {
						webui::SetProgressMessage("Calculating elements per page...");
						
						empty p_calc_idPerPage;
						
						for i_id do
						    for (i_page) | ord(i_id) <= val(i_page) * p_quantityElementsPerPage do
						
						        p_calc_idPerPage(i_id, i_page) := 1;
						        break;
						    endfor;
						endfor;
					}
				}
				Procedure pr_previousPage {
					Body: {
						if ep_currentPage = first(i_page) then
						    !do nothing
						else    
						    ep_currentPage -= 1;
						
						endif;
					}
				}
				Procedure pr_firstPage {
					Body: {
						ep_currentPage := first(i_page);
					}
				}
				Procedure pr_nextPage {
					Body: {
						if ep_currentPage = last(i_page) then
						    !do nothing
						else  
						    ep_currentPage += 1;
						endif;
					}
				}
				Procedure pr_lastPage {
					Body: {
						ep_currentPage := last(i_page);
					}
				}
				Set s_def_pages {
					Index: i_page;
					Definition: {
						{1 .. p_def_numberOfPages}
					}
				}
				ElementParameter ep_currentpage {
					Range: s_def_pages;
				}
				Set s_def_idsPerPage {
					SubsetOf: s_ids;
					Index: i_pg_id;
					Definition: {
						{i_id | p_calc_idPerPage(i_id, ep_currentPage)}
					}
				}
				Parameter p_def_numberOfPages {
					Property: NoSave;
					Definition: ceil(p_def_cardID /$ p_quantityElementsPerPage);
				}
				Parameter p_def_cardID {
					Definition: card(s_ids);
				}
				StringParameter sp_def_currentPage {
					Definition: "Page " + ep_currentPage + " of " + card(s_def_pages);
				}
				Parameter p_quantityElementsPerPage {
					Range: [0, 50000];
					InitialData: 450;
					webui::TooltipIdentifier: sp_def_tooltipQuantityElementsPerPage;
					webui::UponChangeProcedure: pr_changeQuantityElementsPerPage;
				}
				StringParameter sp_def_tooltipQuantityElementsPerPage {
					Definition: "By changing this value, the quantity of elements per page will change.";
				}
				Parameter p_calc_idPerPage {
					IndexDomain: (i_id,i_page);
					Range: binary;
				}
				StringParameter sp_def_inputPageSecondaryActions {
					IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
					Definition: {
						{
							( '1', 'displaytext' ) : "Import",  
							( '1', 'icon'        ) : "aimms-upload",  
							( '1', 'procedure'   ) : "pr_importDataset",  
							( '1', 'state'       ) : "Active"
						}
					}
				}
			}
			Section Results {
				StringParameter sp_def_tooltipCommentToInvestigate {
					Definition: {
						"Please enter the comment you want to invesigate here!"
					}
				}
				StringParameter sp_queryToInvestigate {
					webui::TooltipIdentifier: sp_def_tooltipCommentToInvestigate;
				}
				StringParameter sp_def_resultPageSecondaryActions {
					IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
					Definition: {
						{
							( '1', 'displaytext' ) : "Check",  
							( '1', 'icon'        ) : "aimms-theater",  
							( '1', 'procedure'   ) : "pr_actionInvestigateWhetherEnteredCommentIsToxic",  
							( '1', 'state'       ) : "Active"
						}
					}
				}
				Set s_askedQueries {
					Index: i_query;
					Parameter: ep_query;
				}
				Set s_def_queryTypes {
					Index: i_qType;
					Definition: {
						{'Toxic', 'Not Toxic'}
					}
				}
				ElementParameter ep_calc_queryAnswer {
					IndexDomain: i_query;
					Range: s_def_queryTypes;
					InitialData: '';
					webui::FlagsIdentifier: sp_def_readonly;
				}
				StringParameter sp_queryAsked {
					IndexDomain: i_query;
					webui::FlagsIdentifier: sp_def_readonly;
				}
				Parameter p_def_queryTypePercentage {
					IndexDomain: i_qType;
					Definition: sum(i_query, ep_calc_queryAnswer(i_query) = i_qType);
				}
				Parameter bp_calc_commentInvestigatedIsToxic {
					Range: binary;
					Comment: "raw result from Python";
				}
				StringParameter sp_calc_imageQueryAnswer;
				Procedure pr_pageOpenResultsPage {
					Body: {
						if not p_def_cardID then
							pr_importDataset();
						endif ;
						
						sp_queryToInvestigate := "<type query to check>" ;
						sp_calc_imageQueryAnswer := "question.png";
						
						currentInputs -= data { bp_calc_commentInvestigatedIsToxic };
					}
				}
				Procedure pr_actionInvestigateWhetherEnteredCommentIsToxic {
					Body: {
						
						pr_determineToxic();
					}
				}
			}
		}
	}
	Section Leverage_biasInAI_service {
		Procedure pr_determineToxic {
			Body: {
				SetElementAdd(s_askedQueries, ep_query, card(i_query) + 1);
				sp_queryAsked(ep_query) := sp_queryToInvestigate;
				sp_calc_imageQueryAnswer := "question.png";
				
				webui::SetProgressMessage("Investigating query...");
				
				pr_callBiasInAI();
				
				p_loc_responseRetrieved := dex::client::WaitForResponses(timeout : 30 * 1000 /* milli seconds */);
				
				if not p_loc_responseRetrieved then
					raise error "no response within 30 seconds" ;
				endif ;
			}
			Parameter p_loc_responseRetrieved;
		}
		Procedure pr_callBiasInAI {
			Body: {
				! Starting current call.
				biasInAI::api::NewCallInstance(ep_loc_callInstance);
				
				block ! Fill in the data for making the request.
				
					! Pass the data from the data model to the corresponding data in the biasInAI library.
					biasInAI::_BiasInAIInput::no_observations(ep_loc_callInstance) := p_def_cardID ;
					biasInAI::_BiasInAIInput::new_comment(ep_loc_callInstance) := sp_queryToInvestigate ;
					biasInAI::_BiasInAIInput::_comments::comments_iter := ElementRange( 1, p_def_cardID );
					biasInAI::_BiasInAIInput::_target::target_iter := ElementRange( 1, p_def_cardID );
				
					ep_loc_iterToId( biasInAI::_BiasInAIInput::_comments::i_comments ) 
					:=  element( s_ids, val( biasInAI::_BiasInAIInput::_comments::i_comments ) );
				
					biasInAI::_BiasInAIInput::_comments::Items(ep_loc_callInstance, biasInAI::_BiasInAIInput::_comments::i_comments) 
					:= 	sp_commentText( ep_loc_iterToId( biasInAI::_BiasInAIInput::_comments::i_comments ) ) ;
				
					biasInAI::_BiasInAIInput::_target::Items(ep_loc_callInstance, biasInAI::_BiasInAIInput::_comments::i_comments) 
					:=  bp_target( ep_loc_iterToId( biasInAI::_BiasInAIInput::_comments::i_comments ) ) ;
				
					block ! Check if we passed the data corectly.
						if card( biasInAI::_BiasInAIInput::_comments::Items ) <> p_def_cardID then
							raise error "internal error passing data \'comments\'" ;
						endif ;
						if card( biasInAI::_BiasInAIInput::_target::Items ) <> p_def_cardID then
							raise error "internal error passing data \'target\'" ;
						endif ;
					endblock ;
				endblock ;
				
				! Install hook, which will copy the data or handle the error
				biasInAI::api::compute_compute_post::UserResponseHook 
				:=  'pr_responseHook' ;
				
				! Start the request.
				biasInAI::api::compute_compute_post::apiCall(ep_loc_callInstance);
			}
			ElementParameter ep_loc_callInstance {
				Range: biasInAI::Instances;
			}
			ElementParameter ep_loc_iterToId {
				IndexDomain: biasInAI::_BiasInAIInput::_comments::i_comments;
				Range: s_ids;
			}
		}
		Procedure pr_responseHook {
			Arguments: (ep_in_callInstance);
			Body: {
				ep_loc_status := biasInAI::api::CallStatusCode(ep_in_callInstance);
				
				if StringLength( sp_queryToInvestigate ) > 5 then
					sp_log_cmtShort := substring( sp_queryToInvestigate, 1, 5 ) + "..." ;
				else
					sp_log_cmtShort := sp_queryToInvestigate ;
				endif ;
				switch (ep_loc_status) do
					'200': ! Call went ok. 
						bp_calc_commentInvestigatedIsToxic := biasInAI::_BiasInAIOutput::is_toxic( ep_in_callInstance );
						ep_calc_queryAnswer(ep_query) := if bp_calc_commentInvestigatedIsToxic then 'Toxic' else 'Not Toxic' endif;
						sp_calc_imageQueryAnswer := if bp_calc_commentInvestigatedIsToxic then "toxic.png" else "not_toxic.png" endif;
						biasInAI::_BiasInAIInput::EmptyInstance(  ep_in_callInstance );
						biasInAI::_BiasInAIOutput::EmptyInstance( ep_in_callInstance );
				
					'422': ! HTTP validation error.
					default:
						raise error formatString("biasInAI::isToxic(%s) failed (instance: \'%e\', status: %e, error: %e): %s",
							sp_log_cmtShort, ep_in_callInstance, 
							biasInAI::api::CallStatusCode(ep_in_callInstance), 
							biasInAI::api::CallErrorCode(ep_in_callInstance),
							"" ! Todo: work on the error elaboration!
							);
				
				endswitch;
			}
			Comment: "Prototype that any request or response user hook procedure must adhere to";
			DeclarationSection Locals {
				ElementParameter ep_in_callInstance {
					Range: dex::Instances;
					Property: Input;
				}
				ElementParameter ep_loc_status {
					Range: dex::HTTPStatusCodes;
				}
				StringParameter sp_log_cmtShort;
			}
		}
	}
	Section Application_initialization_and_termination {
		Procedure pr_startup {
			Body: {
				dex::ReadAllMappings();
				
				if pro::GetPROEndPoint() then
					raise error "Initializing server on the AIMMS Cloud not yet implemented." ;
					! See however, https://gitlab.aimms.com/joris/aimms-with-python-service/#making-the-python-sources-available-in-aimms-pro-storage
					! for initializing the server in the AIMMS Cloud.
				else
					! Just use the service started by PyCharm on the biasInAI project.
					biasInAI::api::APIServer :=  "http://localhost:8000" ;
				endif ;
				
				display dex::Mappings ;
			}
		}
		Procedure MainInitialization {
			Comment: "Add initialization statements here that do NOT require any library being initialized already.";
		}
		Procedure PostMainInitialization {
			Body: {
				webui::SetProgressMessage("Initializing dataset...");
				pr_importDataset;
				
				webui::SetProgressMessage("Initializing inputs page...");
				ep_currentpage := first(i_page);
				p_quantityElementsPerPage := 450;
				
				pr_changeQuantityElementsPerPage;
			}
			Comment: {
				"Add initialization statements here that require that the libraries are already initialized properly,
				or add statements that require the Data Management module to be initialized."
			}
		}
		Procedure MainExecution;
		Procedure PreMainTermination {
			Body: {
				return 1 ; ! We don't work with cases.
				!return DataManagementExit();
			}
			Comment: {
				"Add termination statements here that require all libraries to be still alive.
				Return 1 if you allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence."
			}
		}
		Procedure MainTermination {
			Body: {
				return 1;
			}
			Comment: {
				"Add termination statements here that do not require all libraries to be still alive.
				Return 1 to allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence.
				It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
			}
		}
	}
}
